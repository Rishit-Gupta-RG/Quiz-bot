def deleteAllMessages(bot, guildId, whitelistChannels):
"""
@param bot the instance of the running bot in use by the calling function
@param guildId the Guild ID in use by the calling function
@param whitelistChannels the list of whitelisted channels from which messages 
        are not deleted
"""
    guild =  bot.get_guild(int(guildId))
    for channel in guild.text_channels:
        if channel.name not in whitelistChannels:
            while(True):
                deleted = await channel.purge(limit=1000)
                if not len(deleted):
                    break

def getAuthorized(ctx,  message_start, message_end, *authorizedRoles):
"""
@param ctx 
"""
    author = ctx.message.author
    authorRoles = [str(role).lower() for role in author.roles[1:]]
    for role in authorizedRoles:
        if role in authorRoles:
            return True, ''
    response = message_start+', or '.join(authorizedRoles)+message_end
    return False, response

def getAuthorAndName(ctx):
"""
Takes the context variable from the calling function and returns the author
object and the author display name, formatted.
@param ctx the context passed to the calling function
@return author the author object
@return authorName the display name of the author
"""
    author = ctx.message.author()
    authorName = str(author.display_name).split("#")[0]
    return author, authorName

def getCommonChannels(bot, guildId, whitelistChannels):
"""
@param bot the instance of the running bot in use by the calling function
@param guildId the Guild ID in use by the calling function
@param whitelistChannels the channels that are not on the commonChannels or on
        the teamChannels
@return commonChannels a dictionary mapping channel names to channel IDs
"""
    guild = bot.get_guild(int(guildId))
    commonChannels = {}
    for channel in guild.text_channels:
        cn = channel.name
        if not (cn.startswith('team') and cn.endswith('-chat')):
            if cn not in whitelistChannels:
                commonChannels[cn] = bot.get_channel(channel.id)
    return commonChannels


def getTeamChannels(bot, guildId, numberOfTeams):
"""
@param bot the instance of the running bot in use by the calling function
@param guildId the Guild ID in use by the calling function
@param numberOfTeams the limit on the number of teams for the quiz
@return teamChannels a dictionary mapping team names to channel IDs
"""
    guild = bot.get_guild(int(guildId))
    teamChannels = {}
    for channel in guild.text_channels:
        cn = channel.name
        if cn.startswith('team') and cn.endswith('-chat'):
            teamNo = int(cn.split('team')[1].split('-chat')[0])
            if teamNo <= numberOfTeams:
                teamChannels[cn.replace('-chat','')] = bot.get_channel(channel.id)
    return teamChannels

    
def getTeamDistribution(bot, guildId, scores, names=False):
"""
@param bot the instance of the running bot in use by the calling function
@param guildId the Guild ID in use by the calling function
@param scores the scores dictionary that also tracks active teams
@return teamDistribution Dictionary of teams and their members
"""
    guild =  bot.get_guild(int(guildId))
    teamDistribution = {}
    for team in scores:
        teamDistribution[team] = []
    for member in guild.members:
        for role in member.roles:
            if role.name.startswith("team"):
                try:
                    assert role.name in teamDistribution
                    if names:
                        teamDistribution[role.name].append(member.display_name)
                    else:
                        teamDistribution[role.name].append(member)
                except:
                    print("Please check that teamnames match roles (no \
                            spaces). Someone might have a role of a team \
                            that isn't in this quiz.")
    return teamDistribution

def getTeamMembers(teamDistribution, team):
"""
@param teamDistribution team distribution generated by getTeamDistribution
@param team the team we are trying to get members of
@return list of string display names of team members
"""
    memberList = []
    for member in teamDistribution[team]:
        memberList.append(member.display_name.split(#)[0])
    return memberList

def getTeam(author):
"""
Takes the author object and returns the team the author is a member of
@param author the author object
"""
    tmp = []
    for role in author.roles[1:]:
        if role.name.startswith('team'):
            tmp.append(str(role.name.lower()))
    team = ', '.join(tmp)
    return team

def unassignTeams(bot, guildId, ctx):
"""
@param bot the instance of the running bot in use by the calling function
@param guildId the Guild ID in use by the calling function
"""
    guild =  bot.get_guild(int(guildId))
    for member in guild.members:
        for role in member.roles:
            if role.name.startswith("team"):
                try:
                    await member.remove_roles(role)
                    response = 'Removing {} from {}.\
                            '.format(str(member.display_name),str(role.name))
                    await ctx.send(str(response))
                except:
                    print("Did not remove",member,"from",role,"because of \
                            permissions. Make the bot an admin and run this again.")
